---
title: Використання Service для доступу до застосунку
weight: 10
description: |-
    Дізнайтесь про Service у Kubernetes.
    Ознайомтесь з тим, як мітки та селектори повʼязані з Service.
    Відкрийте доступ до застосунку по за межами Kubernetes кластера.
---

<!DOCTYPE html>

<html lang="uk">

<body>

<div class="layout" id="top">

	<main class="content">

		<div class="row">
			<div class="col-md-8">
            <h3>Мета</h3>
				<ul>
                    <li>Дізнатись про Service у Kubernetes.</li>
                    <li>Ознайомитись з тим, як мітки та селектори повʼязані з Service.</li>
                    <li>Відкрити доступ до застосунку по за межами Kubernetes кластера.</li>
				</ul>
			</div>

            <div class="col-md-8">
                <h3>Огляд Сервісів в Kubernetes</h3>
                <p>Існування Podʼів в Kubernetes є обмеженими за часом, також вони мають свій <a href="/uk/docs/concepts/workloads/pods/pod-lifecycle/">життєвий цикл</a>. Коли робочий вузол припиняє існування, також втрачаються Podʼи, які виконуються на цьому вузлі. <a href="/uk/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a> може динамічно приводити кластер до бажаного стану шляхом створення нових Podʼів, щоб ваш застосунок продовжував працювати. Наприклад, розгляньмо обробник зображень, що має 3 копії. Ці копії (репліки) можуть бути взаємозамінні; система форонтенду не повинна перейматися репліками бекенду або навіть тим, чи Pod втрачено та створено наново. Проте кожен Pod в кластері Kubernetes має унікальну IP-адресу, навіть Podʼи на одному вузлі, тому потрібно мати спосіб автоматичного узгодження змін серед Podʼів, щоб ваші застосунки продовжували працювати.</p>

                <p>Service в Kubernetes є абстракцією, яка визначає логічний набір Podʼів та політику доступу до них. Serviceʼи забезпечують слабку звʼязаність між залежними Podʼами. Service визначається за допомогою YAML або JSON, так само як і всі обʼєкти Kubernetes. Набір Podʼів, на які призначений Service, зазвичай визначається <i>селектором міток (label selector)</i> (див. нижче, чому <code>selector</code> іноді не включають у специфікацію Service).</p>

                <p>Хоча кожний Pod має унікальну IP-адресу, ці IP не доступні за межі кластера без використання Service. Serviceʼи уможливлюють надходження трафіку до ваших застосунків. Serviceʼи можуть бути оприлюднені у різний спосіб, за допомогою <code>type</code> у <tt>spec</tt> Service:</p>
                <ul>
                    <li><i>ClusterIP</i> (типове значення) — відкриває доступ до внутрішнього IP Service в кластері. Цей тип робить Service доступним лише зсередини кластера.</li>
                    <li><i>NodePort</i> — відкриває доступ до Service на тому ж порті кожного обраного вузла в кластері за допомогою NAT. Робить Service доступним ззовні кластера за допомогою <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>. Є надмножиною відносно ClusterIP.</li>
                    <li><i>LoadBalancer</i> — створює зовнішній балансувальник навантаження в поточному хмарному середовищі (якщо підтримується) та призначає фіксовану зовнішню IP-адресу для Service. Є надмножиною відносно NodePort.</li>
                    <li><i>ExternalName</i> — звʼязує Service з вмістом поля <code>externalName</code> (наприклад, <code>foo.bar.example.com</code>), повертаючи запис <code>CNAME</code> із його значенням. Не встановлюється жодного проксі. Цей тип вимагає v1.7 або вище <code>kube-dns</code> або CoreDNS версії 0.0.8 або вище.</li>
                </ul>
                <p>Додаткову інформацію про різновиди Service можна знайти у посібнику <a href="/uk/docs/tutorials/services/source-ip/">Використання IP-адреси джерела</a>. Дивіться також <a href="/uk/docs/tutorials/services/connect-applications-service/">Підключення застосунків за допомогою Service</a>.</p>
                <p>Крім того, слід зауважити, що існують випадки використання Service, при яких не визначається <code>selector</code> у специфікації. Service, створений без <code>selector</code>, також не створить відповідний обʼєкт <i>Endpoints</i>. Це дозволяє користувачам вручну відкривати доступ Service на конкретні точки доступу. Ще одна можливість, чому може бути відсутній селектор — використання виключно <code>type: ExternalName</code>.</p>
            </div>

			<div class="col-md-4">
				<div class="content__box content__box_lined">
                    <h3>Зміст</h3>
					<ul>
                        <li>Відкриття Podʼів для зовнішнього трафіка</li>
                        <li>Балансування навантаження трафіку між Podʼами</li>
                        <li>Використання міток</li>
					</ul>
				</div>
				<div class="content__box content__box_fill">
                        <p><i>Service в Kubernetes – це рівень абстракції, який визначає логічний набір Podʼів і дозволяє експонування зовнішнього трафіку, балансування навантаження та виявлення служб для цих Podʼів.</i></p>
				</div>
			</div>
		</div>
		<br>

		<div class="row">
			<div class="col-md-8">
                <h3>Services та мітки (Labels)</h3>
			</div>
		</div>

        <div class="row">
            <div class="col-md-8">
                <p>Service маршрутизує трафік набору Podʼів. Service є абстракцією, яка дозволяє Podʼам зникати та реплікуватися в Kubernetes, не впливаючи на ваш застосунок. Виявлення та маршрутизація серед залежних Podʼів (таких як компоненти frontend та backend у застосунку) обробляються Serviceʼами Kubernetes.</p>
                <p>Service визначають набір Podʼів за допомогою <a href="/uk/docs/concepts/overview/working-with-objects/labels">міток та селекторів</a>, примітиву гуртування, який дозволяє логічно взаємодіяти з обʼєктами в Kubernetes. Мітки — це пари ключ/значення, призначені обʼєктам та можуть бути використані різними способами:</p>
                <ul>
                    <li>Призначення обʼєктів до оточення розробки, тестування та експлуатації</li>
                    <li>Вбудовування теґів версій</li>
                    <li>Класифікація обʼєкта за допомогою теґів</li>
                </ul>
            </div>
        </div>

        <br>

		<div class="row">
			<div class="col-md-8">
				<p><img src="/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg"></p>
			</div>
		</div>
        <br>

        <div class="row">
            <div class="col-md-8">
                <p>Мітки можна прикріплювати до обʼєктів при їх створенні або пізніше. Їх можна змінювати в будь-який час. Давайте зараз використаємо Service для надання доступу до нашого застосунку та застосуємо деякі мітки.</p>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
                <h3>Крок 1: Створення нового Service</h3>
                <p>Перевіримо, що наш застосунок працює. Ми використовуватимемо команду <code>kubectl get</code> та переглядатимемо наявні Podʼи:</p>
                <p><code><b>kubectl get pods</b></code></p>
                <p>Якщо Podʼи не запущені, це означає, що обʼєкти з попередніх кроків були видалені. У цьому випадку поверніться та створіть Deployment з посібника <a href="/uk/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro#deploy-an-app">Використання kubectl для створення Deployment</a>. Зачекайте кілька секунд та перегляньте список Podʼів знову. Ви можете продовжити, як тільки побачите, що один Pod працює.</p>
                <p>Далі виведемо список наявних Serviceʼів у нашому кластері:</p>
                <p><code><b>kubectl get services</b></code></p>
                <p>У нас є Service з назвою <tt>kubernetes</tt>, яка створюється стандартно, коли minikube запускає кластер. Щоб створити новий Service та зробити зовнішній трафік доступним для нього, ми використовуватимемо команду expose з параметром NodePort.</p>
                <p><code><b>kubectl expose deployment/kubernetes-bootcamp --type="NodePort" --port 8080</b></code></p>
                <p>Давайте знову запустимо команду <code>get services</code>:</p>
                <p><code><b>kubectl get services</b></code></p>
                <p>Тепер у нас є робочий Service з назвою kubernetes-bootcamp. Тут ми бачимо, що Service отримав унікальний IP в кластері, внутрішній порт та зовнішній IP (IP вузла).</p>
                <p>Щоб дізнатися, який порт був відкритий ззовні (для Serviceʼу з <tt>type: NodePort</tt>), ми запустимо команду <code>describe service</code>:</p>
                <p><code><b>kubectl describe services/kubernetes-bootcamp</b></code></p>
                <p>Створимо змінну середовища з назвою <tt>NODE_PORT</tt>, яка матиме значення порту вузла:</p>
                <p><code><b>export NODE_PORT="$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}')"</b></code><br />
                <code><b>echo "NODE_PORT=$NODE_PORT"</b></code></p>
                <p>Тепер ми можемо перевірити, що застосунок отримав доступ за межі кластера, використовуючи <code>curl</code>, IP-адресу вузла та зовнішній  порт:</p>
                <p><code><b>curl http://"$(minikube ip):$NODE_PORT"</b></code></p>

                {{< note >}}
                <p>Якщо ви використовуєте minikube з Docker Desktop як драйвер контейнера, потрібно використовувати minikube tunnel. Це тому, що контейнери всередині Docker Desktop ізольовані від вашого компʼютера.<br>
                <p>В окремому вікні термінала виконайте:<br>
                <code><b>minikube service kubernetes-bootcamp --url</b></code></p>
                <p>Вивід виглядає так:
                <pre><b>http://127.0.0.1:51082<br>!  Because you are using a Docker driver on darwin, the terminal needs to be open to run it.</b></pre></p>
                <p>Потім використовуйте вказаний URL для доступу до застосунку:<br>
                <code><b>curl 127.0.0.1:51082</b></code></p>
                {{< /note >}}

                <p>І, ми отримуємо відповідь від сервера. Service — працює.</p>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
                <h3>Крок 2: Використання міток</h3>
                <div class="content">
                <p>Deployment автоматично створив мітку для нашого Podʼа. За допомогою команди <code>describe deployment</code> ви можете побачити імʼя (<i>ключ</i>) цієї мітки:</p>
                <p><code><b>kubectl describe deployment</b></code></p>
                <p>Використаємо цю мітку для отримання списку наших Podʼів. Ми використовуватимемо команду <code>kubectl get pods</code> з <tt>-l</tt> як параметр, за яким слідують значення мітки:</p>
                <p><code><b>kubectl get pods -l app=kubernetes-bootcamp</b></code></p>
                <p>Ви можете зробити те саме, щоб вивести список поточних служб:</p>
                <p><code><b>kubectl get services -l app=kubernetes-bootcamp</b></code></p>
                <p>Отримайте назву Podʼа та збережіть її в змінній середовища <tt>POD_NAME</tt>:</p>
                <p><code><b>export POD_NAME="$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')"</b></code><br />
                <code><b>echo "Name of the Pod: $POD_NAME"</b></code></p>
                <p>Для застосування нової мітки ми використовуємо команду <code>label</code> за якою слідує тип обʼєкта, назва обʼєкта та нова мітка:</p>
                <p><code><b>kubectl label pods "$POD_NAME" version=v1</b></code></p>
                <p>Це додасть нову мітку до нашого Podʼа (ми закріпили версію програми для Podʼа), і ми можемо перевірити це за допомогою команди describe pod:</p>
                <p><code><b>kubectl describe pods "$POD_NAME"</b></code></p>
                <p>Тут ми бачимо, що мітка тепер прикріплена до нашого Podʼа. І тепер ми можемо отримати список Podʼів, використовуючи нову мітку:</p>
                <p><code><b>kubectl get pods -l version=v1</b></code></p>
                <p>І, ми бачимо Pod.</p>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
                <h3>Крок 3: Видалення Service</h3>
                <p>Для видалення Service ви можете використовувати команду <code>delete service</code>. Тут також можна використовувати мітки:</p>
                <p><code><b>kubectl delete service -l app=kubernetes-bootcamp</b></code></p>
                <p>Переконайтеся, що Service видалено:</p>
                <p><code><b>kubectl get services</b></code></p>
                <p>Це підтверджує, що наш Service видалено. Щоб переконатися, що маршрут більше не відкритий, ви можете перевірити раніше відкриті IP та порт за допомогою <tt>curl</tt>:</p>
                <p><code><b>curl http://"$(minikube ip):$NODE_PORT"</b></code></p>
                <p>Це доводить, що застосунок більше не доступний ззовні кластера. Ви можете переконатись, що застосунок все ще працює за допомогою <tt>curl</tt> зсередини Podʼа:</p>
                <p><code><b>kubectl exec -ti $POD_NAME -- curl http://localhost:8080</b></code></p>
                <p>Тут ми бачимо, що застосунок працює. Це тому, що Deployment управляє застосунком. Для припинення роботи застосунку вам слід видалити також й Deployment.</p>
            </div>
        </div>

        <div class="row">
            <p>
                Одразу, як тільки ви будете готові, переходьте до <a href="/uk/docs/tutorials/kubernetes-basics/scale/scale-intro/" title="Running Multiple Instances of Your App">Запуску кількох екземплярів вашого застосунку</a>.
            </p>
        </div>
	</main>
</div>

</body>
</html>
